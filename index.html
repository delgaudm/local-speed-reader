<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Local Speed Reader</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#111824;
      --text:#e7eef7;
      --muted:#97a6bb;
      --accent:#6ee7ff;
      --danger:#ff4d4d;
      --border:rgba(255,255,255,.10);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1200px 800px at 30% 20%, rgba(110,231,255,.08), transparent 60%),
                  radial-gradient(900px 700px at 80% 70%, rgba(255,77,77,.06), transparent 60%),
                  var(--bg);
      color:var(--text);
      min-height:100vh;
      display:flex;
      align-items:stretch;
      justify-content:center;
      padding:18px;
    }
    .app{
      width:min(1100px, 100%);
      display:grid;
      grid-template-columns: 380px 1fr;
      gap:16px;
    }
    @media (max-width: 900px){
      .app{ grid-template-columns: 1fr; }
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--border);
      border-radius:18px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .cardHeader{
      padding:14px 16px;
      border-bottom:1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .title{
      font-size:14px;
      letter-spacing:.4px;
      color:var(--muted);
      text-transform:uppercase;
    }
    .hint{
      font-size:12px;
      color:var(--muted);
      line-height:1.35;
    }
    textarea{
      width:100%;
      min-height:260px;
      resize:vertical;
      background: rgba(0,0,0,.25);
      border:1px solid var(--border);
      border-radius:12px;
      color:var(--text);
      padding:12px;
      outline:none;
      line-height:1.4;
    }
    textarea:focus{ border-color: rgba(110,231,255,.35); box-shadow: 0 0 0 4px rgba(110,231,255,.08); }

    .controls{
      padding:14px 16px;
      display:grid;
      gap:12px;
    }
    .row{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .row3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:10px;
    }
    label{ font-size:12px; color:var(--muted); display:block; margin-bottom:6px; }
    input[type="number"], input[type="text"], select{
      width:100%;
      background: rgba(0,0,0,.25);
      border:1px solid var(--border);
      border-radius:12px;
      color:var(--text);
      padding:10px 10px;
      outline:none;
    }
    input[type="number"]:focus, input[type="text"]:focus, select:focus{
      border-color: rgba(110,231,255,.35);
      box-shadow: 0 0 0 4px rgba(110,231,255,.08);
    }
    input[type="file"]{ width:100%; color:var(--muted); }

    .btns{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
    }
    button{
      background: rgba(255,255,255,.06);
      border:1px solid var(--border);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
      transition: transform .06s ease, background .15s ease, border-color .15s ease;
      user-select:none;
    }
    button:hover{ background: rgba(255,255,255,.09); border-color: rgba(110,231,255,.25); }
    button:active{ transform: translateY(1px); }
    .primary{ border-color: rgba(110,231,255,.35); background: rgba(110,231,255,.10); }
    .danger{ border-color: rgba(255,77,77,.35); background: rgba(255,77,77,.08); }
    .pill{
      font-size:12px;
      color:var(--muted);
      border:1px solid var(--border);
      border-radius:999px;
      padding:6px 10px;
      display:inline-flex;
      gap:8px;
      align-items:center;
    }
    .dot{
      width:8px; height:8px; border-radius:999px;
      background: rgba(151,166,187,.45);
    }
    .dot.playing{ background: rgba(110,231,255,.85); box-shadow: 0 0 0 6px rgba(110,231,255,.12); }

    /* Reader */
    .reader{
      min-height: 520px;
      display:flex;
      flex-direction:column;
    }
    .stage{
      flex:1;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:22px;
    }
    .wordBox{
      width:min(740px, 100%);
      height:240px;
      display:flex;
      align-items:center;
      justify-content:center;
      border-radius:22px;
      border:1px solid var(--border);
      background: rgba(0,0,0,.18);
      position:relative;
    }
    .word{
      font-size: clamp(34px, 6vw, 72px);
      letter-spacing: 0.5px;
      font-weight: 650;
      line-height: 1;
      text-align:center;
      padding: 0 18px;
      word-break: break-word;
    }
    .orp{ color: var(--danger); }

    .progress{
      position:absolute;
      left:16px;
      right:16px;
      bottom:16px;
      height:10px;
      background: rgba(255,255,255,.06);
      border:1px solid var(--border);
      border-radius:999px;
      overflow:hidden;
    }
    .bar{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, rgba(110,231,255,.7), rgba(110,231,255,.15));
      transition: width .08s linear;
    }

    .readerFooter{
      padding:14px 16px;
      border-top:1px solid var(--border);
      display:flex;
      flex-wrap:wrap;
      justify-content:space-between;
      gap:10px;
      align-items:center;
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.25);
      color: var(--muted);
      margin: 0 2px;
    }

    .toast{
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 16px;
      background: rgba(17,24,36,.92);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      box-shadow: var(--shadow);
      font-size: 13px;
      opacity: 0;
      pointer-events: none;
      transition: opacity .18s ease;
      max-width: min(760px, 92vw);
    }
    .toast.show{ opacity: 1; }
  </style>
</head>
<body>
  <div class="app">
    <!-- Left: input & settings -->
    <section class="card">
      <div class="cardHeader">
        <div>
          <div class="title">Input</div>
          <div class="hint">Paste text, or load a local .txt file. Then hit <b>Load</b>.</div>
        </div>
      </div>
      <div class="controls">
        <textarea id="inputText" placeholder="Paste text here…\n\nTip: This is a local page. Nothing is uploaded anywhere."></textarea>

        <div>
          <label for="fileInput">Load a local text file</label>
          <input id="fileInput" type="file" accept="text/plain,.txt,.md" />
        </div>

        <div class="btns">
          <button id="loadBtn" class="primary">Load</button>
          <button id="clearBtn" class="danger">Clear</button>
          <span class="pill"><span id="statusDot" class="dot"></span><span id="statusText">Idle</span></span>
        </div>

        <div class="cardHeader" style="padding:0; border-bottom:none;">
          <div>
            <div class="title">Playback settings</div>
            <div class="hint">Starts at <b>300 WPM</b> and ramps to <b>700 WPM</b> (configurable).</div>
          </div>
        </div>

        <div class="row">
          <div>
            <label for="minWpm">Start WPM</label>
            <input id="minWpm" type="number" min="50" max="2000" value="300" />
          </div>
          <div>
            <label for="maxWpm">Max WPM</label>
            <input id="maxWpm" type="number" min="50" max="3000" value="700" />
          </div>
        </div>

        <div class="row">
          <div>
            <label for="rampWords">Ramp over (words)</label>
            <input id="rampWords" type="number" min="10" max="5000" value="450" />
          </div>
          <div>
            <label for="fontScale">Word size</label>
            <select id="fontScale">
              <option value="0.85">Small</option>
              <option value="1" selected>Normal</option>
              <option value="1.15">Large</option>
              <option value="1.35">Huge</option>
            </select>
          </div>
        </div>

        <div class="row3">
          <div>
            <label for="pausePunct">Punctuation pause</label>
            <select id="pausePunct">
              <option value="1.00">Off</option>
              <option value="1.20">Light</option>
              <option value="1.45" selected>Normal</option>
              <option value="1.80">Heavy</option>
            </select>
          </div>
          <div>
            <label for="pausePara">Paragraph pause</label>
            <select id="pausePara">
              <option value="1.00">Off</option>
              <option value="1.60" selected>Normal</option>
              <option value="2.20">Heavy</option>
            </select>
          </div>
          <div>
            <label for="anchorMode">Anchor</label>
            <select id="anchorMode">
              <option value="middle" selected>Middle letter</option>
              <option value="orp">ORP-style</option>
            </select>
          </div>
        </div>

        <div class="hint">
          Keyboard: <span class="kbd">Space</span> play/pause · <span class="kbd">←</span>/<span class="kbd">→</span> back/forward · <span class="kbd">R</span> restart · <span class="kbd">Esc</span> stop
        </div>
      </div>
    </section>

    <!-- Right: reader -->
    <section class="card reader">
      <div class="cardHeader">
        <div>
          <div class="title">Reader</div>
          <div class="hint" id="stats">Load some text to begin.</div>
        </div>
        <div class="btns">
          <button id="backBtn">⟲ Back 10</button>
          <button id="playBtn" class="primary">▶ Play</button>
          <button id="forwardBtn">Forward 10 ⟳</button>
          <button id="restartBtn">↺ Restart</button>
        </div>
      </div>

      <div class="stage">
        <div class="wordBox" aria-live="polite" aria-atomic="true">
          <div id="word" class="word">Ready.</div>
          <div class="progress"><div id="bar" class="bar"></div></div>
        </div>
      </div>

      <div class="readerFooter">
        <div class="pill">
          <span>WPM:</span>
          <b id="wpmNow">—</b>
          <span style="opacity:.5">·</span>
          <span>Word:</span>
          <b id="posNow">0/0</b>
        </div>
        <div class="hint">Tip: click the reader, then use the keyboard.</div>
      </div>
    </section>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

<script>
(() => {
  // Elements
  const el = {
    inputText: document.getElementById('inputText'),
    fileInput: document.getElementById('fileInput'),
    loadBtn: document.getElementById('loadBtn'),
    clearBtn: document.getElementById('clearBtn'),

    minWpm: document.getElementById('minWpm'),
    maxWpm: document.getElementById('maxWpm'),
    rampWords: document.getElementById('rampWords'),
    fontScale: document.getElementById('fontScale'),
    pausePunct: document.getElementById('pausePunct'),
    pausePara: document.getElementById('pausePara'),
    anchorMode: document.getElementById('anchorMode'),

    statusDot: document.getElementById('statusDot'),
    statusText: document.getElementById('statusText'),

    playBtn: document.getElementById('playBtn'),
    backBtn: document.getElementById('backBtn'),
    forwardBtn: document.getElementById('forwardBtn'),
    restartBtn: document.getElementById('restartBtn'),

    word: document.getElementById('word'),
    bar: document.getElementById('bar'),
    stats: document.getElementById('stats'),
    wpmNow: document.getElementById('wpmNow'),
    posNow: document.getElementById('posNow'),

    toast: document.getElementById('toast'),
  };

  // State
  let tokens = [];              // array of {t: string, paraBreak: boolean}
  let i = 0;
  let playing = false;
  let timer = null;
  let loadedAt = 0;

  // Helpers
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));

  // Smoothstep easing (nice acceleration)
  const smoothstep = (x) => {
    x = clamp(x, 0, 1);
    return x * x * (3 - 2 * x);
  };

  function toast(msg){
    el.toast.textContent = msg;
    el.toast.classList.add('show');
    clearTimeout(toast._t);
    toast._t = setTimeout(() => el.toast.classList.remove('show'), 1400);
  }

  function setStatus(text, isPlaying){
    el.statusText.textContent = text;
    el.statusDot.classList.toggle('playing', !!isPlaying);
  }

  function readSettings(){
    const minWpm = clamp(parseInt(el.minWpm.value || '300', 10), 50, 2000);
    const maxWpm = clamp(parseInt(el.maxWpm.value || '700', 10), 50, 3000);
    const rampWords = clamp(parseInt(el.rampWords.value || '450', 10), 10, 5000);
    const pausePunct = parseFloat(el.pausePunct.value || '1.45');
    const pausePara = parseFloat(el.pausePara.value || '1.60');
    const anchorMode = el.anchorMode.value || 'middle';
    const fontScale = parseFloat(el.fontScale.value || '1');

    // Ensure min <= max
    const a = Math.min(minWpm, maxWpm);
    const b = Math.max(minWpm, maxWpm);

    return { minWpm: a, maxWpm: b, rampWords, pausePunct, pausePara, anchorMode, fontScale };
  }

  function applyFontScale(){
    const { fontScale } = readSettings();
    el.word.style.transform = `scale(${fontScale})`;
  }

  function isPunctHeavy(tok){
    // Strong punctuation gets a bigger pause
    return /[.!?]\s*$/.test(tok);
  }
  function isPunctLight(tok){
    // Light punctuation gets a modest pause
    return /[,;:]\s*$/.test(tok);
  }

  function computeWpm(index){
    const { minWpm, maxWpm, rampWords } = readSettings();
    const progress = smoothstep(index / rampWords);
    return minWpm + (maxWpm - minWpm) * progress;
  }

  function computeDelayMs(index){
    const { pausePunct, pausePara } = readSettings();
    const wpm = computeWpm(index);
    let base = 60000 / wpm;

    const tok = tokens[index]?.t || '';

    // Add pauses
    if (tokens[index]?.paraBreak) base *= pausePara;
    if (isPunctHeavy(tok)) base *= (pausePunct + 0.35);
    else if (isPunctLight(tok)) base *= pausePunct;

    // Extra dwell for long words (your “panic saccade” issue).
    // Heuristic: for core length > 9, add ~6% per extra character, capped.
    const core = tok.replace(/^[^A-Za-z0-9]+|[^A-Za-z0-9]+$/g, '');
    const L = core.length;
    if (L > 9){
      const factor = clamp(1 + (L - 9) * 0.06, 1, 2.2);
      base *= factor;
    }

    return { delay: clamp(base, 20, 7000), wpm };
  }

  function tokenize(text){
    // Preserve paragraph breaks so we can pause on them.
    // We'll mark tokens that come right after a blank line as paraBreak.

    let s = String(text || '');
    s = s.replaceAll('\r\n', '\n').replaceAll('\r', '\n');

    // Remove fenced code blocks ``` ... ```
    while (true){
      const a = s.indexOf('```');
      if (a === -1) break;
      const b = s.indexOf('```', a + 3);
      if (b === -1){
        s = s.slice(0, a);
        break;
      }
      s = s.slice(0, a) + ' ' + s.slice(b + 3);
    }

    // Inline code: `code` -> code
    while (true){
      const a = s.indexOf('`');
      if (a === -1) break;
      const b = s.indexOf('`', a + 1);
      if (b === -1) break;
      s = s.slice(0, a) + s.slice(a + 1, b) + s.slice(b + 1);
    }

    // Markdown images: ![alt](url) -> alt
    // Markdown links:  [text](url) -> text
    let outStr = '';
    for (let i2 = 0; i2 < s.length; ){
      const isImg = s.startsWith('![', i2);
      const isLink = s[i2] === '[';
      if (!isImg && !isLink){
        outStr += s[i2++];
        continue;
      }
      const startBracket = i2 + (isImg ? 2 : 1);
      const endBracket = s.indexOf(']', startBracket);
      if (endBracket === -1){ outStr += s[i2++]; continue; }
      const openParen = s.indexOf('(', endBracket + 1);
      if (openParen !== endBracket + 1){ outStr += s[i2++]; continue; }
      const closeParen = s.indexOf(')', openParen + 1);
      if (closeParen === -1){ outStr += s[i2++]; continue; }

      const label = s.slice(startBracket, endBracket);
      outStr += label;
      i2 = closeParen + 1;
    }
    s = outStr;

    // Remove emphasis markers (keep content)
    s = s.split('**').join('');
    s = s.split('__').join('');
    s = s.split('*').join('');
    s = s.split('_').join('');

    // Strip common markdown prefixes at line starts
    const lines = s.split('\n');
    for (let k = 0; k < lines.length; k++){
      let line = lines[k];

      // trim up to 3 leading spaces
      let j = 0;
      while (j < line.length && j < 3 && line[j] === ' ') j++;
      line = line.slice(j);

      // headings like "### Title"
      while (line.startsWith('#')) line = line.slice(1);
      if (line.startsWith(' ')) line = line.slice(1);

      // blockquote
      if (line.startsWith('>')){
        line = line.slice(1);
        if (line.startsWith(' ')) line = line.slice(1);
      }

      // bullets
      if (line.startsWith('- ') || line.startsWith('* ') || line.startsWith('+ ')){
        line = line.slice(2);
      }

      lines[k] = line;
    }
    s = lines.join('\n');

    // Em/en dashes as separators (Option A)
    s = s.split('—').join(' ');
    s = s.split('–').join(' ');

    // Split hyphenated words into separate tokens (per user preference)
    // This treats hyphens as word separators.
    s = s.split('-').join(' ');

    // Fix missing spaces after sentence punctuation before letters.
    // "context.The" -> "context. The" (doesn't affect decimals like 3.14)
    s = s.replace(/([a-z])[.](?=[A-Z])/g, '$1. ');
    s = s.replace(/([A-Za-z])([!?])(?=[A-Za-z])/g, '$1$2 ');

    // Normalize whitespace
    s = s.replaceAll('\t', ' ');
    while (s.includes('  ')) s = s.replaceAll('  ', ' ');
    while (s.includes('\n\n\n')) s = s.replaceAll('\n\n\n', '\n\n');

    s = s.trim();
    if (!s) return [];

    const paragraphs = s.split('\n\n');
    const out = [];

    for (let p = 0; p < paragraphs.length; p++){
      let para = paragraphs[p].split('\n').join(' ').trim();
      if (!para) continue;
      while (para.includes('  ')) para = para.replaceAll('  ', ' ');

      const words = para.split(' ').filter(Boolean);
      for (let w = 0; w < words.length; w++){
        out.push({ t: words[w], paraBreak: (w === 0 && p !== 0) });
      }
    }

    return out;
  }

  function anchorIndex(word){
    const mode = (readSettings().anchorMode);

    // Strip leading/trailing punctuation for anchor selection
    const m = word.match(/^([^A-Za-z0-9]*)(.*?)([^A-Za-z0-9]*)$/);
    const lead = m ? m[1] : '';
    const core = m ? m[2] : word;

    if (!core) return Math.floor(word.length / 2);

    let idxCore;

    if (mode === 'middle'){
      idxCore = Math.floor(core.length / 2);
    } else {
      // ORP-ish (common heuristic):
      // 1-2 letters: 0
      // 3-5: 1
      // 6-9: 2
      // 10-13: 3
      // 14+: 4
      const L = core.length;
      if (L <= 2) idxCore = 0;
      else if (L <= 5) idxCore = 1;
      else if (L <= 9) idxCore = 2;
      else if (L <= 13) idxCore = 3;
      else idxCore = 4;
      idxCore = clamp(idxCore, 0, Math.max(0, L - 1));
    }

    return lead.length + idxCore;
  }

  function renderWord(word){
    if (!word){
      el.word.textContent = 'Done.';
      return;
    }

    const idx = anchorIndex(word);

    const safe = word;
    const left = safe.slice(0, idx);
    const mid = safe.slice(idx, idx + 1);
    const right = safe.slice(idx + 1);

    // Build spans so only the anchor letter is red.
    el.word.innerHTML = '';
    const s1 = document.createElement('span'); s1.textContent = left;
    const s2 = document.createElement('span'); s2.textContent = mid || ''; s2.className = 'orp';
    const s3 = document.createElement('span'); s3.textContent = right;

    el.word.appendChild(s1);
    el.word.appendChild(s2);
    el.word.appendChild(s3);
  }

  function updateHUD(){
    const total = tokens.length;
    el.posNow.textContent = `${Math.min(i, total)}/${total}`;

    if (!total){
      el.wpmNow.textContent = '—';
      el.bar.style.width = '0%';
      el.stats.textContent = 'Load some text to begin.';
      return;
    }

    const { wpm } = computeDelayMs(Math.min(i, total - 1));
    el.wpmNow.textContent = `${Math.round(wpm)}`;
    el.bar.style.width = `${(i / total) * 100}%`;

    const approxMinutesLeft = Math.max(0, ((total - i) * (60000 / Math.max(1, wpm))) / 60000);
    el.stats.textContent = `${total.toLocaleString()} words loaded · ~${approxMinutesLeft.toFixed(1)} min remaining at current speed`;
  }

  function stop(){
    playing = false;
    clearTimeout(timer);
    timer = null;
    el.playBtn.textContent = '▶ Play';
    setStatus(tokens.length ? 'Paused' : 'Idle', false);
    updateHUD();
  }

  function step(){
    if (!playing) return;

    if (i >= tokens.length){
      stop();
      setStatus('Done', false);
      toast('Finished.');
      return;
    }

    const tok = tokens[i];
    renderWord(tok.t);

    const { delay, wpm } = computeDelayMs(i);
    el.wpmNow.textContent = `${Math.round(wpm)}`;

    i++;
    updateHUD();

    timer = setTimeout(step, delay);
  }

  function playPause(){
    if (!tokens.length){
      toast('Load some text first.');
      return;
    }
    playing = !playing;
    if (playing){
      setStatus('Playing', true);
      el.playBtn.textContent = '⏸ Pause';
      step();
    } else {
      stop();
    }
  }

  function restart(){
    stop();
    i = 0;
    renderWord(tokens[0]?.t || 'Ready.');
    updateHUD();
    setStatus(tokens.length ? 'Ready' : 'Idle', false);
  }

  function jump(delta){
    if (!tokens.length) return;
    stop();
    i = clamp(i + delta, 0, tokens.length);
    renderWord(tokens[i]?.t || (i >= tokens.length ? 'Done.' : tokens[0]?.t));
    updateHUD();
    setStatus('Paused', false);
  }

  function loadFromText(text){
    stop();
    tokens = tokenize(text);
    i = 0;
    loadedAt = Date.now();

    if (!tokens.length){
      renderWord('Ready.');
      setStatus('Idle', false);
      updateHUD();
      toast('No readable words found.');
      return;
    }

    renderWord(tokens[0].t);
    setStatus('Ready', false);
    updateHUD();
    toast(`Loaded ${tokens.length.toLocaleString()} words.`);
  }

  // ---- Minimal tests (console) ----
  // These guard against regressions in tokenize() heuristics.
  function runTokenizeTests(){
    const cases = [
      {
        name: 'inserts missing space after period before Uppercase',
        input: 'This is context.The next word.',
        expectTokens: ['This','is','context.','The','next','word.'],
      },
      {
        name: 'does not split decimals',
        input: 'Pi is 3.14 and e is 2.71828.',
        mustContain: ['3.14','2.71828.'],
      },
      {
        name: 'splits hyphenated words',
        input: 'state-of-the-art solutions',
        expectTokens: ['state','of','the','art','solutions'],
      },
      {
        name: 'inserts missing space after ! and ?',
        input: 'Stop!Wait What?Now',
        expectTokens: ['Stop!','Wait','What?','Now'],
      },
      {
        name: 'marks paragraph break tokens',
        input: 'Para one.

Para two starts.',
        expectParaBreakAtToken: 'Para', // the first token of para 2
      }
    ];

    const assert = (cond, msg) => { if (!cond) throw new Error(msg); };

    for (const tc of cases){
      const out = tokenize(tc.input);
      const words = out.map(x => x.t);

      if (tc.expectTokens){
        assert(JSON.stringify(words) === JSON.stringify(tc.expectTokens),
          `${tc.name}: expected ${JSON.stringify(tc.expectTokens)} got ${JSON.stringify(words)}`);
      }
      if (tc.mustContain){
        for (const w of tc.mustContain){
          assert(words.includes(w), `${tc.name}: expected tokens to include ${w} but got ${JSON.stringify(words)}`);
        }
      }
      if (tc.expectParaBreakAtToken){
        const idx = words.indexOf(tc.expectParaBreakAtToken);
        // first token is also 'Para' so we expect the second paragraph's first token to have paraBreak=true
        const paraBreakIndex = out.findIndex((x, j) => x.paraBreak && x.t === tc.expectParaBreakAtToken && j !== 0);
        assert(paraBreakIndex !== -1, `${tc.name}: expected a paraBreak token '${tc.expectParaBreakAtToken}' in paragraph 2`);
      }

      console.log('[tests] ok:', tc.name);
    }
  }

  // Events
  el.loadBtn.addEventListener('click', () => loadFromText(el.inputText.value));
  el.clearBtn.addEventListener('click', () => {
    stop();
    el.inputText.value = '';
    el.fileInput.value = '';
    tokens = [];
    i = 0;
    loadedAt = 0;
    el.word.textContent = 'Ready.';
    setStatus('Idle', false);
    updateHUD();
    toast('Cleared.');
  });

  el.fileInput.addEventListener('change', async (e) => {
    const f = e.target.files?.[0];
    if (!f) return;
    try {
      const text = await f.text();
      el.inputText.value = text;
      toast(`Loaded file: ${f.name}`);
    } catch {
      toast('Could not read file.');
    }
  });

  el.playBtn.addEventListener('click', playPause);
  el.restartBtn.addEventListener('click', restart);
  el.backBtn.addEventListener('click', () => jump(-10));
  el.forwardBtn.addEventListener('click', () => jump(10));

  el.fontScale.addEventListener('change', applyFontScale);
  el.anchorMode.addEventListener('change', () => {
    renderWord(tokens[i]?.t || tokens[i-1]?.t || 'Ready.');
  });

  // Keep settings sane
  function sanitizeWpm(){
    const a = parseInt(el.minWpm.value || '300', 10);
    const b = parseInt(el.maxWpm.value || '700', 10);
    if (Number.isFinite(a) && Number.isFinite(b) && a > b){
      // swap values if user crosses them
      el.minWpm.value = String(b);
      el.maxWpm.value = String(a);
      toast('Swapped Start/Max WPM.');
    }
  }
  el.minWpm.addEventListener('change', () => { sanitizeWpm(); updateHUD(); });
  el.maxWpm.addEventListener('change', () => { sanitizeWpm(); updateHUD(); });
  el.rampWords.addEventListener('change', updateHUD);
  el.pausePunct.addEventListener('change', updateHUD);
  el.pausePara.addEventListener('change', updateHUD);

  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    // Don't steal keys while typing in inputs
    const tag = (e.target?.tagName || '').toLowerCase();
    if (tag === 'textarea' || tag === 'input' || tag === 'select') return;

    if (e.code === 'Space'){
      e.preventDefault();
      playPause();
    } else if (e.code === 'ArrowLeft'){
      e.preventDefault();
      jump(-1);
    } else if (e.code === 'ArrowRight'){
      e.preventDefault();
      jump(1);
    } else if (e.key.toLowerCase() === 'r'){
      restart();
    } else if (e.code === 'Escape'){
      stop();
      toast('Stopped.');
    }
  });

  // Initial
  try {
    runTokenizeTests();
  } catch (err){
    console.error(err);
    toast('Internal tests failed — check console.');
  }

  applyFontScale();
  setStatus('Idle', false);
  updateHUD();
})();
</script>
</body>
</html>
